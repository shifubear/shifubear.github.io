{
  "hash": "af19e50f1f2b6301bba645dd0b9f8654",
  "result": {
    "markdown": "---\ntitle: \"Optimal Amplitude Estimation\"\nauthor: \"Shion Fukuzawa\"\ndate: \"2023-01-24\"\ncategories: [research, quantum]\ndraft: true\n---\n\nSuppose we have a polynomial time boolean function $f$ that takes $n$ bits as input. We would like to give an estimate as to how many of the possible input strings evaluate to 1. We could take our function and try each valid input one at a time, but this would take $2^n$ evaluations of the function. \n\nIf we can implement a function classically, we can also do so using a quantum computer by encoding the effect of the function into a unitary $U_f$. The effect of applying this unitary can be described by the following equation: \n\n$$U_f\\left|x\\right>_n\\left|0\\right> = \\left|x\\right>_n\\left|f(x)\\right>.$$\n\nIn words, if the input string $x$ is stored in the first register, after applying our unitary we store the result of evaluating $f$ with input $x$ in the second register. \n\nNow let's see what happens when we apply this unitary when the first register is in uniform superposition. \n\n$$U_f H^{\\otimes n} \\left|0\\right>_n \\left|0\\right> = \\sum_{x\\in \\{0,1\\}^n}U_f\\left|x\\right>_n\\left|0\\right> = \\sum_{x\\in \\{0,1\\}^n} \\left|x\\right>_n\\left|f(x)\\right>.$$\n\nNow our quantum computer stores the result of evaluating all possible $n$ bit inputs for our function $f$, and the neat part is that it only required one call to our unitary $U_f$. However, this is still not enough. Because of the rule of measurements in \n\n# Problem Statement \n\n\nIn the setting of quantum counting, we can think of this operator first putting the first $n$ qubits into superposition over all $n$ bit strings, then applying some function $f$ that marks a state by setting the $n+1$-th qubit to 1.\n\n\nSuppose we are given an unknown quantum operator $A$ that acts on $n + 1$ qubits as follows: \n\n$$A \\left|0\\right>_n\\left|0\\right> = \\sqrt{1-a} \\left|\\psi_0\\right>_n\\left|0\\right> + \\sqrt{a}\\left|\\psi_1\\right>_n \\left|1\\right>.$$\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np \n\nprint(np.sin(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.1411200080598672\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}