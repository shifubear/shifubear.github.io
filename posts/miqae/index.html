<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Shion Fukuzawa">
<meta name="dcterms.date" content="2023-01-24">

<title>Shion Fukuzawa - Optimal Amplitude Estimation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Shion Fukuzawa</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html">
 <span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research.html">
 <span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/shifubear"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Optimal Amplitude Estimation</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">research</div>
                <div class="quarto-category">quantum</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Shion Fukuzawa </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 24, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Suppose we are given a black box to evaluate some boolean function <span class="math inline">\(f\)</span> that takes <span class="math inline">\(n\)</span> bits as input. We would like to give an estimate as to how many of the possible input strings evaluate to 1. We will call an input that outputs 1 a success. Now it’s possible to take our function and go through all possible inputs, but this would require <span class="math inline">\(2^n\)</span> evaluations of the function.</p>
<p>Let’s say we decide that it’s not worth going through all possibilities, and we can settle for an approximate estimate of how many input strings are successful. One strategy we might use to accomplish this is by picking a random bit string and checking if it’s successful or not. After some <span class="math inline">\(n\)</span> trials, we will have a record of how many of those were successful or not. What we’ve done here is model the original problem as estimating the success probability of a Bernoulli distribution, and asking how many samples we need to approximate this distribution well.</p>
<p>To accomplish this we can use a tool called a Chernoff bound. There are many versions of Chernoff bounds, but the one that is relevant here is the following:</p>
<p><span class="math display">\[\mathbb{P}[a \not \in [\hat{a}-\epsilon, \hat{a}+\epsilon]] \leq 2e^{-2N\epsilon^2}.\]</span></p>
<p>Here, <span class="math inline">\(a\)</span> is the true success probability of our coin flip, <span class="math inline">\(\hat{a}\)</span> is our estimate for <span class="math inline">\(a\)</span> after <span class="math inline">\(N\)</span> trials, and <span class="math inline">\(\epsilon\)</span> is some target interval we want our estimate to lie between. Essentially what the equation is expressing is that as we take more trials, the probability that our estimate is off by more than <span class="math inline">\(\epsilon\)</span> decreases <em>exponentially</em>. Let’s say we want to say that there’s a 99 percent chance that our approximation of <span class="math inline">\(a\)</span> is within <span class="math inline">\(\epsilon\)</span> of the correct solution. Then we can set the right hand side to 0.01 (since it bounds the failure probability) and solve for <span class="math inline">\(N\)</span>:</p>
<p><span class="math display">\[2e^{-2N\epsilon^2} = 0.01 \Rightarrow N = \frac{1}{2\epsilon^2} \log \frac{2}{0.01}.\]</span></p>
<p>Can we do any better? It turns out that if we use a quantum computer the answer is yes! The first thing we need to do is to come up with a way to evaluate the function <span class="math inline">\(f\)</span> with our quantum computer.</p>
<p>It turns out that if we can implement a function with a classical circuit, we can also do so using a quantum computer by encoding the effect of the function into a unitary <span class="math inline">\(U_f\)</span> with not too much overhead. The effect of applying this unitary can be described by the following equation:</p>
<p><span class="math display">\[U_f\left|x\right&gt;_n\left|0\right&gt; = \left|x\right&gt;_n\left|f(x)\right&gt;.\]</span></p>
<p>In words, we store the input string <span class="math inline">\(x\)</span> in the first register, and after applying our unitary the result of evaluating <span class="math inline">\(f\)</span> with input <span class="math inline">\(x\)</span> is stored in the second register.</p>
<p>Now let’s see what happens when we apply this unitary when the first register is in uniform superposition, which we can accomplish by applying a Hadamard gate to each qubit we have.</p>
<p><span class="math display">\[U_f H^{\otimes n} \left|0\right&gt;_n \left|0\right&gt; = \sum_{x\in \{0,1\}^n}U_f\left|x\right&gt;_n\left|0\right&gt; = \sum_{x\in \{0,1\}^n} \left|x\right&gt;_n\left|f(x)\right&gt;.\]</span></p>
<p>Now we have all input output pairs of our function stored in superposition, which we were able to prepare with just one call to our unitary <span class="math inline">\(U_f\)</span>. There is still a small problem, namely that we need to measure from the quantum computer to get a result, and measuring will collapse our superposition state into the result we observe. If this was all we could do, we haven’t improved at all from the classical setting, we just made a more contrived Bernoulli sampling problem.</p>
<p>In the remaining sections, I’ll describe one way to speed up the process with a quantum computer that came about through joint work with Sandy Irani, Chris Ho, and Jasen Zion. Currently, this is provably the most efficient way to solve the problem that is known.</p>
<section id="problem-statement" class="level1">
<h1>Problem Statement</h1>
<p>Before getting into the details of the algorithm, it’ll be helpful to restate the problem a little more formally. The most common way this problem is presented in the literature is the following.</p>
<p>Suppose we are given an unknown quantum operator <span class="math inline">\(A\)</span> that acts on <span class="math inline">\(n + 1\)</span> qubits as follows:</p>
<p><span class="math display">\[A \left|0\right&gt;_n\left|0\right&gt; = \sqrt{1-a} \left|\psi_0\right&gt;_n\left|0\right&gt; + \sqrt{a}\left|\psi_1\right&gt;_n \left|1\right&gt;.\]</span></p>
<p>The question is, how many times do we need to apply <span class="math inline">\(A\)</span> to have an estimate of <span class="math inline">\(a\)</span> within some target precision <span class="math inline">\(\epsilon\)</span>, with failure probability less than <span class="math inline">\(\alpha\)</span>.</p>
<p>If we model the classical setting of this problem with a quantum computer, what we do is prepare the state described above and take a measurement right away. This requires <span class="math inline">\(O\left(\frac{1}{\epsilon^2} \log \frac{2}{\alpha}\right)\)</span> samples to solve the problem, as we showed using the Chernoff bounds above.</p>
<p>Using a procedure called amplitude amplification, we can accomplish the same estimate with <span class="math inline">\(O\left(\frac{1}{\epsilon} \log \frac{2}{\alpha}\right)\)</span>, a quadratic improvement over the classical procedure.</p>
</section>
<section id="amplitude-amplification" class="level1">
<h1>Amplitude Amplification</h1>
<p>I’m going to rewrite our state as follows:</p>
<p><span class="math display">\[A\left|0\right&gt;_n \left|0\right&gt; = \sqrt{1-a}\left|\psi_0\right&gt;\left|0\right&gt; + \sqrt{a}\left|\psi_1\right&gt;\left|1\right&gt;.\]</span></p>
<p><span class="math display">\[\Downarrow\]</span></p>
<p><span class="math display">\[A\left|0\right&gt;_n \left|0\right&gt; = \cos{\theta} \left|\psi_0\right&gt;\left|0\right&gt; + \sin{\theta} \left|\psi_1\right&gt;\left|1\right&gt;,\]</span></p>
<p>where I’m defining <span class="math inline">\(\theta\)</span> as the angle such that <span class="math inline">\(\sin^2 \theta = a\)</span>. Since <span class="math inline">\(\left|\psi_0\right&gt;\left|0\right&gt;\)</span> and <span class="math inline">\(\left|\psi_1\right&gt;\left|1\right&gt;\)</span> are orthogonal subspaces, I can draw this state as follows:</p>
<p><img src="figs/aa1.jpeg" class="img-fluid"></p>
<p>An early result for this algorithm was that if we have our operator <span class="math inline">\(A\)</span>, it’s possible to construct a new operator <span class="math inline">\(Q\)</span> which is a combination of two actions: 1. Reflect the state across the <span class="math inline">\(x\)</span> axis, and 2. Reflect the state across the starting state.</p>
<p><img src="figs/aa2.jpeg" class="img-fluid"> <img src="figs/aa3.jpeg" class="img-fluid"></p>
<p>What’s neat about doing this is that now our success probability has increased from <span class="math inline">\(\sin^2(\theta)\)</span> to <span class="math inline">\(\sin^2(3\theta)\)</span>. More generally, if we apply this operator <span class="math inline">\(k\)</span> times we can boost the success probability up to <span class="math inline">\(\sin^2((2k+1)\theta)\)</span>.</p>
<p>This technique is used quite often in quantum algorithms, and has been a key tool in many results that achieve a quadratic speedup over classical algorithms.</p>
</section>
<section id="algorithm" class="level1">
<h1>Algorithm</h1>
<p>We’re now ready to dive into the algorithm, which is actually quite simple once you followed everything up to here. There are two phases to the algorithm.</p>
<section id="main-phase" class="level2">
<h2 class="anchored" data-anchor-id="main-phase">Main phase</h2>
<p>In the main phase, we maintain some guess of the interval we believe <span class="math inline">\(\theta\)</span> lies in. Initially, we know for certain that the angle lies somewhere between <span class="math inline">\(0\)</span> and <span class="math inline">\(\pi/2\)</span>, so that will be our starting interval. Recall that we defined <span class="math inline">\(\theta\)</span> such that <span class="math inline">\(\sin^2 \theta = a\)</span>. We can use this fact to take our interval containing <span class="math inline">\(\theta\)</span> and map it to an interval containing <span class="math inline">\(a\)</span>. Now we take samples from our quantum circuit to construct our approximation for <span class="math inline">\(a\)</span>, and we can use the Chernoff bound to shrink our confidence interval. Once we’ve shrinken the interval a certain amount, we can now take our new bounds for the interval containing <span class="math inline">\(a\)</span>, and construct an interval containing <span class="math inline">\(\theta\)</span>.</p>
<p><img src="figs/miqae1.jpeg" class="img-fluid"> <img src="figs/miqae2.jpeg" class="img-fluid"> <img src="figs/miqae3.jpeg" class="img-fluid"> <img src="figs/miqae4.jpeg" class="img-fluid"></p>
<p>What we don’t want to do is take samples until the interval has shrunk to the accuracy we want, since that would be identical to the classical algorithm. Instead, what we use is the fact that early samples help gain more information than later samples do. Once the returns of information gain from a single sample is lower than some threshold, we move on to the second phase.</p>
</section>
<section id="findnextk" class="level2">
<h2 class="anchored" data-anchor-id="findnextk">FindNextK</h2>
<p>In the second phase of the algorithm, we use amplitude amplification to generate a new distribution, such that the information we gain from the samples increases again.</p>
<p>The procedure is called FindNextK, since we are looking for the best number of times <span class="math inline">\(k\)</span> to apply our amplitude amplification operator <span class="math inline">\(Q\)</span>, so that we can gain useful information from our samples.</p>
<p>Geometrically, all we are trying to do is to scale up our confidence interval for <span class="math inline">\(\theta\)</span> such that 1. it is as wide as possible, and 2. it is fully contained within one quadrant.</p>
<p>We want 1 because the wider this interval is, the more information we can obtain using a small number of samples, and we want 2 because we need to be able to invert the function <span class="math inline">\(\sin^2\)</span> unambiguously.</p>
<p>Once we’ve found the best next <span class="math inline">\(k\)</span> value, we simply run the main phase of the algorithm for this distribution until we decide we should find a new <span class="math inline">\(k\)</span> again.</p>
<p><img src="figs/fnk1.jpeg" class="img-fluid"> <img src="figs/fnk2.jpeg" class="img-fluid"> <img src="figs/fnk3.jpeg" class="img-fluid"> <img src="figs/fnk4.jpeg" class="img-fluid"> <img src="figs/fnk5.jpeg" class="img-fluid"> <img src="figs/fnk6.jpeg" class="img-fluid"></p>
<p>And that’s it! The following diagram describes the whole algorithm:</p>
<p><img src="figs/MIQAE-algorithm1.png" class="img-fluid"></p>
<p>The key technical challenge is figuring out the best time to start finding the next value of <span class="math inline">\(k\)</span>. One thing that we observed and used is that the circuit is much simpler for small values of <span class="math inline">\(k\)</span>, and the depth grows very fast throughout the algorithm. Because of this, we argued that it is optimal to try to spend a bit more time on early samples, so that a smaller number of samples is sufficient towards the end of the algorithm when the circuit is very expensive to prepare.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="shifubear/shifubear.github.io" data-repo-id="R_kgDOIgiXHw" data-category="General" data-category-id="DIC_kwDOIgiXH84CS3yH" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>