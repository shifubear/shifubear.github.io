<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Shion Fukuzawa">
<meta name="dcterms.date" content="2022-12-20">

<title>Shion Fukuzawa - Counting with Quantum Computers</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Shion Fukuzawa</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html">
 <span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/shifubear"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Counting with Quantum Computers</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">research</div>
                <div class="quarto-category">quantum</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Shion Fukuzawa </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">December 20, 2022</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p><em>[This article is an overview of joint work with Sandy Irani, Chris Ho, and Jasen Zion: <a href="https://arxiv.org/abs/2208.14612">preprint</a>]</em></p>
<p>(This post is organized into several levels. You can read through the post upto whatever level you desire, each adding a little more depth to the discussion of the topic. Level 1 is targeted at a general audience, requiring minimal knowledge of math, computer science, and physics. Level 2 is targeted towards undergraduates in related fields. Level 3 is targeted towards graduate students studying quantum computing.)</p>
<section id="level-1-introduction" class="level1">
<h1>Level 1: Introduction</h1>
<p>Imagine a room full of boxes numbered from 1 through a very large number <span class="math inline">\(N\)</span>. You’re not allowed to go into this room, but you notice that there is someone inside. When you give the oracle a number, it goes and opens the box for you. After yelling out a few numbers, you notice that some boxes are empty, but some boxes are filled with treasure. Can you come up with an efficient way to approximate the number of boxes that are filled with treasure?</p>
<p>This problem is called the “approximate counting” problem in computer science. It turns out that with a classical computer, you can’t do much better than opening each box one at a time. That is, if there are <span class="math inline">\(N\)</span> boxes, you’ll need about <span class="math inline">\(N\)</span> moves. This is a great problem to learn a little about the power of quantum computers, which can get a very good solution by only using <span class="math inline">\(\sqrt{N}\)</span> moves. The advantage of using quantum computers for this problem was demonstrated in 1998 in the paper by <a href="https://arxiv.org/pdf/quant-ph/9805082.pdf">Brassard, Høyer and Tapp</a> and their algorithm is taught in many introductory quantum computing courses. We won’t go into the details of that algorithm here, but the algorithm described here borrows some key techniques from that original work.</p>
<p>The last decade has been an exciting time for quantum computing, as we have seen the first physical realizations of an idea which has been purely theoretical for several decades. You may have noticed something strange here: If quantum computers have been physically created only so recently, how did people like Brassard design algorithms for the technology? Well, since the development of quantum physics, many brilliant scientists had hopes that we could make use of the unusual phenomenon to help speed up certain computational tasks. With this goal in mind, many physicists and computer scientists constructed a theoretical framework for modeling computation that follows quantum mechanical rules. From these basic rules, many algorithms were designed which could be shown to require less computational resources than a traditional computer would. An example of this is the approximate counting problem that we will be studying here.</p>
<p>Though we are seeing many physical devices, they are still very much in their infancy in terms of size and performance. The quantum computers we have today can only run on very small problems, and can’t fully take advantage of “quantum mechanical circuits” that many of the algorithms designed by theorists require. Because of this, we will still need to wait several years before seeing these algorithms in action. However, we still want to make use of the quantum computers that have been created. To supplement their weakness, there has been a lot of recent work on constructing hybrid algorithms. We know that quantum computers are very good at certain problems, but we also know that for many other problems, they can’t do much better than the computers we have today. Using this information, we can use quantum computers for exactly the part of the algorithm that they excel at, and let the classical computer do the rest of the work. We showed in our work a hybrid algorithm that is much easier for the quantum computer to run than Brassard et al.’s algorithm, but still has the <em>same scaling in terms of computational resources required</em>.</p>
<section id="high-level-description" class="level2">
<h2 class="anchored" data-anchor-id="high-level-description">High level description</h2>
<p>Using a classical computer to solve this problem is like having one robot inside the room full of boxes. We can give it one instruction at a time, meaning if we want to check <span class="math inline">\(N\)</span> boxes, we need to give it <span class="math inline">\(N\)</span> instructions. One way to think of a quantum computer in this setting, is that our robot is able to split into smaller clones, and we can give one instruction for all of the clones to execute at the same time. A useful way to do this for this setting is to split the robot in a way where each clone is standing across a different box. Then we can give the single command, “open the box in front of you”. Often times conversations about quantum advantage ends here, claiming that this parallelization is how quantum computers speed up computation. The problem with this statement is that the hard part about designing quantum algorithms usually begins <em>after</em> this step.</p>
<p>After we give the instruction to all the clones, we now need to check each clone to see what the result of their action was. So in a way, we transformed the problem of checking one box at a time, to now checking one clone at a time. The difference though, is that we are able to combine the information the clones have in useful ways to solve the problem, while the boxes could only be opened and closed.</p>
<p>These types of problems have been very well studied, and what we know is that for problems like this is that quantum computers offer up to a <em>quadratic</em> speed up. This is pretty good, but no where near an <em>exponential speed up</em> which can be achieved for different problems. In the next section, I introduce some of the mathematical techniques we use, and give a more technical description of the algorithm.</p>
</section>
</section>
<section id="level-2-technical-description-and-the-algorithm" class="level1">
<h1>Level 2: Technical description and the algorithm</h1>
<p>To describe the math behind the algorithm, we will need to introduce a slightly different version of the problem. I’ll explain how to use this method to solve the original counting problem later in this post.</p>
<section id="amplitude-estimation" class="level2">
<h2 class="anchored" data-anchor-id="amplitude-estimation">Amplitude estimation</h2>
<p>Suppose that we have an unknown quantum gate <span class="math inline">\(A\)</span> that acts on <span class="math inline">\(n + 1\)</span> qubits that we can apply as many times as we want. Mathematically, we describe the action by</p>
<p><span class="math display">\[A\left|0\right&gt;_n\left|0\right&gt; = \sqrt{1 - a}\left|\psi_0\right&gt;_n\left|0\right&gt; + \sqrt{a}\left|\psi_1\right&gt;_n\left|1\right&gt;.\]</span></p>
<p>We will call the states whose last qubit are <span class="math inline">\(\left|1\right&gt;\)</span> as the <strong>marked</strong> states. Once this state is generated, we can measure it and will find a marked state with probability <span class="math inline">\(a\)</span>. At this point, the problem is basically approximating the probability a biased coin will be heads. In quantum computing, the square root of the probability is called the amplitude of a state, and so this general problem is referred to as the <strong>amplitude estimation problem</strong>.</p>
<p>If we are able to precisely approximate the probability of finding a marked state, this probability corresponds to the density of marked states out of all possible states. This gives a simple way to convert between amplitude estimation and approximate counting.</p>
</section>
<section id="chernoff-bounds" class="level2">
<h2 class="anchored" data-anchor-id="chernoff-bounds">Chernoff bounds</h2>
<p>Let’s figure out how many times we would have to run our first circuit to determine what the probability of success <span class="math inline">\(a\)</span> is. First, we will formalize the problem a little more. We would like to approximate what <span class="math inline">\(a\)</span> is up to some precision which we will represent with the variable <span class="math inline">\(\epsilon\)</span>, which we are very confident about. To quantify our confidence, we introduce another variable <span class="math inline">\(\delta\)</span>. At the end of our algorithm, we want to be able to say that the probability that we are wrong is at most <span class="math inline">\(\delta\)</span> (or that the probability we are right is at least <span class="math inline">\(1 - \delta\)</span>).</p>
<p>Ideally we want these two numbers to be as close to 0 as possible. Intuitively, it is not hard to imagine that the more times we flip our coin, the better idea of the probability we have with higher confidence.</p>
<p>It turns out that this scenario is so ubiquitous, there is a well known tool to give us a very good approximation on how many times we need to flip the coin. The following equation is what is called a Chernoff bound, which does exactly what we need. I won’t derive it here, but there is a <a href="https://math.mit.edu/~goemans/18310S15/chernoff-notes.pdf">great reference</a> for those who want to learn more.</p>
<p><span class="math display">\[\mathbb{P}[a \not \in [\hat{a}-\epsilon, \hat{a}+\epsilon]] \leq 2e^{-2N\epsilon}\]</span></p>
<p>The equation may look intimidating at first, but we can break it down to understand it</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="shifubear/shifubear.github.io" data-repo-id="R_kgDOIgiXHw" data-category="General" data-category-id="DIC_kwDOIgiXH84CS3yH" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->



</body></html>